# Troll

The *troll* is a C-language source-level debugger for *ARM Cortex-M* systems,
accessed with the excellent *blackmagic* hardware debug probe, and a customized
variant of the *blackmagic* - the *vx/blackstrike* (or *blackstrike* for short).
The *troll* only supports source-level debugging of source code programs
written in the *C* programming language, compiled to executable files in the
*ELF* format, containig *DWARF* debug information.

Note that this is a very special case of a debugger:
- it only targets *ARM* Cortex-M based systems
- only the C language is supported for source-level debugging
- only the *blackmagic* and *blackstrike* hardware debug probes are supported

### How source-level debuggers work

When a compiler generates an object file from a source code file,
the compiler annotates the generated machine code instructions and
data with special information that a source-level debugger can
understand. When a program misbehaves, it can be loaded in the
debugger, which, by using the debug information generated by the
compiler, can show and modify the values of variables, halt
the program for inspection, execute the program machine-code-instruction
stepwise or source-code linewise for
better understanding of what is happening, inspect and modify
target memory and registers, set breakpoints so that the program
halts for inspection when a certain source-code statement is
about to be executed or a certain variable is accessed, and many other
useful and helpful things.

The debug information format that nowadays is the de-facto standard
is the *DWARF* format, the documents of the *DWARF* standard are
freely available for download [here](http://www.dwarfstd.org/).

### How to perform source-level debugging, without a source-level debugger

Following is a description how debug information generated by the
compiler can be used to manually perform the tasks that are usually
done with the aid of a debugger.
To illustrate this technique, I will try to explain the generated
debug information for the following simple program:

```c

volatile int x = 10, y = 5;

static int fib(int n)
{
	if (n < 2)
		return n;
	return fib(n - 1) + fib(n - 2);
}

int main (void)
{
	return fib(x);
}

```

To understand the debug information generated by the compiler, a
basic understanding of the *DWARF* debug format is needed.
I will try to briefly explain how the *DWARF* debug information
is organized in the *ELF* file of the compiled program.

First thing to know is that the generated debug information
for even the simple program above, can be ***large***.
This cannot be overstressed. Let us have a look at some numbers.

File 'Qt5Guid.dll' of my Qt 5.7.0 installation is a windows dynamic
library (*dll*). Technically, it is not an *ELF* formatted file,
but as it was compiled with the *gcc* compiler, the generated
debug information is in the *DWARF* format. The size of this
file on my machine is about **200 megabytes**. The size of the
generated machine code and data that take up space in this file
is about **5 (five) megabytes**. The remaining **195
megabytes** is debug information. That basically means, that
for this code sample, about***2.5%*** of the data in the file
is for use by the machine, and the remaining about ***97.5%***
of the data in the file are for use by a debugger. I.e., for
this code sample, almost ***100%*** of the file, created
by the compiler, is for use by a debugger. This is not a
contrived example, it is absolutely real.

Because usually the generated debug information is quite large,
the *DWARF* debug information uses some specific encodings and data
representation techniques in an attempt to make the debug
information more compact.

The *DWARF* debug information, that maps human-created source code
to machine-consumable code, is based on some common observations
of how humans expect such a mapping to behave:
- (assumption 1) a line of source code corresponds to some machine-code instruction(s)
generated by the compiler
- (assumption 2) a variable in the program exists somewhere in the memory
of the target machine

A term that is very often used when discussing the *DWARF* debug format
is the *debugging information entry*, or *DIE* for short. 
Quoting the *DWARF* standard:

> DWARF uses a series of debugging information entries (DIEs) to define a low-level
> representation of a source program. Each debugging information entry consists of an identifying
> tag and a series of attributes. An entry, or group of entries together, provide a description of a
> corresponding entity in the source program. The tag specifies the class to which an entry belongs
> and the attributes define the specific characteristics of the entry.

*DIEs* are laid in a tree structure in the generated debug information.
Usually, for each source code file compiled, the compiler emits a so-called
*compilation unit* *DIE*, which is the root of the tree of debug
information generated for the source code file compiled. Other
entities in the source code, such as variables, subprograms, data
types, are descendant nodes in the tree with root the *DIE* of the compilation
unit.

Let us compile this program, and inspect the debug information generated
by the compiler. I compiled the program with the following options:
```sh
arm-none-eabi-gcc -c -o test.o test.c -mcpu=cortex-m3 -mthumb -g -O0
```
Let us now decode the generated debug information, and see what it looks like.
This is done with the `objdump` utility:
```sh
objdump -W test.o
```
Note that, because the *DWARF* debug information is by design independent
of the target for which the program is compiled, I can use my native
`objdump` utility (which in this case is for *x86* targets, instead
of the longer to type `arm-none-eabi-objdump` compiled to target
*Cortex-M* systems. When generating disassembly dumps later, though,
I must of course use the 'proper objdump'.

This is the decoded debug information:
```

test.o:     file format elf32-little

Contents of the .debug_info section:

  Compilation Unit @ offset 0x0:
   Length:        0x87 (32-bit)
   Version:       4
   Abbrev Offset: 0x0
   Pointer Size:  4
 <0><b>: Abbrev Number: 1 (DW_TAG_compile_unit)
    <c>   DW_AT_producer    : (indirect string, offset: 0x0): GNU C 4.9.3 20141119 (release) [ARM/embedded-4_9-branch revision 218278] -mcpu=cortex-m3 -mthumb -g -O0	
    <10>   DW_AT_language    : 1	(ANSI C)
    <11>   DW_AT_name        : (indirect string, offset: 0x7b): test.c	
    <15>   DW_AT_comp_dir    : (indirect string, offset: 0x68): X:\troll\cxx-tests	
    <19>   DW_AT_low_pc      : 0x0	
    <1d>   DW_AT_high_pc     : 0x4c	
    <21>   DW_AT_stmt_list   : 0x0	
 <1><25>: Abbrev Number: 2 (DW_TAG_subprogram)
    <26>   DW_AT_name        : fib	
    <2a>   DW_AT_decl_file   : 1	
    <2b>   DW_AT_decl_line   : 4	
    <2c>   DW_AT_prototyped  : 1	
    <2c>   DW_AT_type        : <0x4b>	
    <30>   DW_AT_low_pc      : 0x0	
    <34>   DW_AT_high_pc     : 0x34	
    <38>   DW_AT_frame_base  : 1 byte block: 9c 	(DW_OP_call_frame_cfa)
    <3a>   DW_AT_GNU_all_tail_call_sites: 1	
    <3a>   DW_AT_sibling     : <0x4b>	
 <2><3e>: Abbrev Number: 3 (DW_TAG_formal_parameter)
    <3f>   DW_AT_name        : n	
    <41>   DW_AT_decl_file   : 1	
    <42>   DW_AT_decl_line   : 4	
    <43>   DW_AT_type        : <0x4b>	
    <47>   DW_AT_location    : 2 byte block: 91 6c 	(DW_OP_fbreg: -20)
 <1><4b>: Abbrev Number: 4 (DW_TAG_base_type)
    <4c>   DW_AT_byte_size   : 4	
    <4d>   DW_AT_encoding    : 5	(signed)
    <4e>   DW_AT_name        : int	
 <1><52>: Abbrev Number: 5 (DW_TAG_subprogram)
    <53>   DW_AT_external    : 1	
    <53>   DW_AT_name        : (indirect string, offset: 0x82): main	
    <57>   DW_AT_decl_file   : 1	
    <58>   DW_AT_decl_line   : 11	
    <59>   DW_AT_prototyped  : 1	
    <59>   DW_AT_type        : <0x4b>	
    <5d>   DW_AT_low_pc      : 0x34	
    <61>   DW_AT_high_pc     : 0x18	
    <65>   DW_AT_frame_base  : 1 byte block: 9c 	(DW_OP_call_frame_cfa)
    <67>   DW_AT_GNU_all_tail_call_sites: 1	
 <1><67>: Abbrev Number: 6 (DW_TAG_variable)
    <68>   DW_AT_name        : x	
    <6a>   DW_AT_decl_file   : 1	
    <6b>   DW_AT_decl_line   : 2	
    <6c>   DW_AT_type        : <0x76>	
    <70>   DW_AT_external    : 1	
    <70>   DW_AT_location    : 5 byte block: 3 0 0 0 0 	(DW_OP_addr: 0)
 <1><76>: Abbrev Number: 7 (DW_TAG_volatile_type)
    <77>   DW_AT_type        : <0x4b>	
 <1><7b>: Abbrev Number: 6 (DW_TAG_variable)
    <7c>   DW_AT_name        : y	
    <7e>   DW_AT_decl_file   : 1	
    <7f>   DW_AT_decl_line   : 2	
    <80>   DW_AT_type        : <0x76>	
    <84>   DW_AT_external    : 1	
    <84>   DW_AT_location    : 5 byte block: 3 0 0 0 0 	(DW_OP_addr: 0)

Contents of the .debug_abbrev section:

  Number TAG (0x0)
   1      DW_TAG_compile_unit    [has children]
    DW_AT_producer     DW_FORM_strp
    DW_AT_language     DW_FORM_data1
    DW_AT_name         DW_FORM_strp
    DW_AT_comp_dir     DW_FORM_strp
    DW_AT_low_pc       DW_FORM_addr
    DW_AT_high_pc      DW_FORM_data4
    DW_AT_stmt_list    DW_FORM_sec_offset
   2      DW_TAG_subprogram    [has children]
    DW_AT_name         DW_FORM_string
    DW_AT_decl_file    DW_FORM_data1
    DW_AT_decl_line    DW_FORM_data1
    DW_AT_prototyped   DW_FORM_flag_present
    DW_AT_type         DW_FORM_ref4
    DW_AT_low_pc       DW_FORM_addr
    DW_AT_high_pc      DW_FORM_data4
    DW_AT_frame_base   DW_FORM_exprloc
    DW_AT_GNU_all_tail_call_sites DW_FORM_flag_present
    DW_AT_sibling      DW_FORM_ref4
   3      DW_TAG_formal_parameter    [no children]
    DW_AT_name         DW_FORM_string
    DW_AT_decl_file    DW_FORM_data1
    DW_AT_decl_line    DW_FORM_data1
    DW_AT_type         DW_FORM_ref4
    DW_AT_location     DW_FORM_exprloc
   4      DW_TAG_base_type    [no children]
    DW_AT_byte_size    DW_FORM_data1
    DW_AT_encoding     DW_FORM_data1
    DW_AT_name         DW_FORM_string
   5      DW_TAG_subprogram    [no children]
    DW_AT_external     DW_FORM_flag_present
    DW_AT_name         DW_FORM_strp
    DW_AT_decl_file    DW_FORM_data1
    DW_AT_decl_line    DW_FORM_data1
    DW_AT_prototyped   DW_FORM_flag_present
    DW_AT_type         DW_FORM_ref4
    DW_AT_low_pc       DW_FORM_addr
    DW_AT_high_pc      DW_FORM_data4
    DW_AT_frame_base   DW_FORM_exprloc
    DW_AT_GNU_all_tail_call_sites DW_FORM_flag_present
   6      DW_TAG_variable    [no children]
    DW_AT_name         DW_FORM_string
    DW_AT_decl_file    DW_FORM_data1
    DW_AT_decl_line    DW_FORM_data1
    DW_AT_type         DW_FORM_ref4
    DW_AT_external     DW_FORM_flag_present
    DW_AT_location     DW_FORM_exprloc
   7      DW_TAG_volatile_type    [no children]
    DW_AT_type         DW_FORM_ref4

Contents of the .debug_aranges section:

  Length:                   28
  Version:                  2
  Offset into .debug_info:  0x0
  Pointer Size:             4
  Segment Size:             0

    Address    Length
    00000000 0000004c 
    00000000 00000000 

Raw dump of debug contents of section .debug_line:

  Offset:                      0x0
  Length:                      55
  DWARF Version:               2
  Prologue Length:             29
  Minimum Instruction Length:  2
  Initial value of 'is_stmt':  1
  Line Base:                   -5
  Line Range:                  14
  Opcode Base:                 13

 Opcodes:
  Opcode 1 has 0 args
  Opcode 2 has 1 args
  Opcode 3 has 1 args
  Opcode 4 has 1 args
  Opcode 5 has 1 args
  Opcode 6 has 0 args
  Opcode 7 has 0 args
  Opcode 8 has 0 args
  Opcode 9 has 1 args
  Opcode 10 has 0 args
  Opcode 11 has 0 args
  Opcode 12 has 1 args

 The Directory Table is empty.

 The File Name Table:
  Entry	Dir	Time	Size	Name
  1	0	0	0	test.c

 Line Number Statements:
  Extended opcode 2: set Address to 0x0
  Special opcode 9: advance Address by 0 to 0x0 and Line by 4 to 5
  Special opcode 62: advance Address by 8 to 0x8 and Line by 1 to 6
  Special opcode 48: advance Address by 6 to 0xe and Line by 1 to 7
  Special opcode 34: advance Address by 4 to 0x12 and Line by 1 to 8
  Special opcode 188: advance Address by 26 to 0x2c and Line by 1 to 9
  Special opcode 64: advance Address by 8 to 0x34 and Line by 3 to 12
  Special opcode 34: advance Address by 4 to 0x38 and Line by 1 to 13
  Special opcode 90: advance Address by 12 to 0x44 and Line by 1 to 14
  Advance PC by 8 to 0x4c
  Extended opcode 1: End of Sequence


Contents of the .debug_str section:

  0x00000000 474e5520 4320342e 392e3320 32303134 GNU C 4.9.3 2014
  0x00000010 31313139 20287265 6c656173 6529205b 1119 (release) [
  0x00000020 41524d2f 656d6265 64646564 2d345f39 ARM/embedded-4_9
  0x00000030 2d627261 6e636820 72657669 73696f6e -branch revision
  0x00000040 20323138 3237385d 202d6d63 70753d63  218278] -mcpu=c
  0x00000050 6f727465 782d6d33 202d6d74 68756d62 ortex-m3 -mthumb
  0x00000060 202d6720 2d4f3000 583a5c74 726f6c6c  -g -O0.X:\troll
  0x00000070 5c637878 2d746573 74730074 6573742e \cxx-tests.test.
  0x00000080 63006d61 696e00                     c.main.

Contents of the .debug_frame section:

00000000 0000000c ffffffff CIE
  Version:               1
  Augmentation:          ""
  Code alignment factor: 2
  Data alignment factor: -4
  Return address column: 14

  DW_CFA_def_cfa: r13 ofs 0

00000010 00000024 00000000 FDE cie=00000000 pc=00000000..00000034
  DW_CFA_advance_loc: 2 to 00000002
  DW_CFA_def_cfa_offset: 12
  DW_CFA_offset: r4 at cfa-12
  DW_CFA_offset: r7 at cfa-8
  DW_CFA_offset: r14 at cfa-4
  DW_CFA_advance_loc: 2 to 00000004
  DW_CFA_def_cfa_offset: 24
  DW_CFA_advance_loc: 2 to 00000006
  DW_CFA_def_cfa_register: r7
  DW_CFA_advance_loc: 42 to 00000030
  DW_CFA_def_cfa_offset: 12
  DW_CFA_advance_loc: 2 to 00000032
  DW_CFA_def_cfa_register: r13
  DW_CFA_nop
  DW_CFA_nop
  DW_CFA_nop

00000038 00000018 00000000 FDE cie=00000000 pc=00000034..0000004c
  DW_CFA_advance_loc: 2 to 00000036
  DW_CFA_def_cfa_offset: 8
  DW_CFA_offset: r7 at cfa-8
  DW_CFA_offset: r14 at cfa-4
  DW_CFA_advance_loc: 2 to 00000038
  DW_CFA_def_cfa_register: r7
  DW_CFA_nop
  DW_CFA_nop

```

This is quite a lot of debug information generated for such a small program.
Let me repeat how the *DWARF* standard describes *DIEs*:

> DWARF uses a series of debugging information entries (DIEs) to define a low-level
> representation of a source program. Each debugging information entry consists of an identifying
> ***tag*** and a series of ***attributes***. An entry, or group of entries together, provide a description of a
> corresponding entity in the source program. The tag specifies the class to which an entry belongs
> and the attributes define the specific characteristics of the entry.

The debug information generated by the compiler resides in several
sections in the *ELF* file created for a program. The most
important sections of debug information are:
- .debug_info
- .debug_abbrev
- .debug_line
- .debug_frame
- .debug_loc
These sections will be described in more detail below.

In the `objdump` output of the decoded debug information, a *DIE* looks like this:
```
<0><b>: Abbrev Number: 1 (DW_TAG_compile_unit)
```
In this example, we have a compilation unit *DIE*.
The first angle-bracketed number, in this example `<0>`, is the nesting level
of the *DIE* in the debug information tree. As already said, a
compilation unit *DIE* is the root of the debug information tree
generated for a source code file during compilation, so
as a root of the tree, the compilation unit *DIE* is at
the outermost nesting level *0*. The second angle-bracketed number,
in this example `<b>` (the number is in hexadecimal) is the
offset of the *DIE* in the *.debug_info* section in the *ELF*
file generated by the compiler. Because *DIEs* cannot physically
overlap, ***it is important to understand that the DIE offset in
the .debug_info section uniquely and unambiguously identifies
a DIE***. Following in the `objdump` generated output is
the *abbreviation number* of the *DIE*, in this case this
is *abbreviation* number 1. As already said, a *DIE* has
a ***tag***, and a series of ***attributes***. The ***tag***
of a *DIE* denotes its type (e.g. a compilation unit, a subprogram,
a variable, and many others). The ***attributes*** of a *DIE*
give details relevant for the *DIE* - e.g. the name of the source
code file that was compiled in order to generate the debug information
tree of a compilation unit, the address of a variable,
the name of a subprogram, and so on.

In the `objdump` output of the decoded debug information, a *DIE* looks like this:
```
 <10>   DW_AT_language    : 1	(ANSI C)
```
An ***attribute*** of a *DIE* has an ***attribute*** ***name*** and an
***attribute*** ***form*** of encoding,
and the *DIE* itself supplies a ***value*** for a given ***attribute*** ***name***,
which ***value*** is encoded in a way specified by the ***attribute***
***form*** of encoding. This relationship between *DIEs* and their associated
***attributes*** is probably vague at this point of presentation, but I hope
this will become clear shortly. The reason for such a relationship is
compactness of representation of *DWARF* debug information in the
compiler generated object files.

That said, let us take this example of a *DWARF* ***attribute***
from the `objdump` output of the decoded debug information for our sample
program from above:
```
 <10>   DW_AT_language    : 1	(ANSI C)
```
In this example, the bracketed number `<10>` is the offset in the
`.debug_info` section, where the ***value*** of the specific
*DWARF* ***attribute*** resides (remember, in the `objdump` dumps,
all offsets in the `.debug_info` section are in hexadecimal, so in
this example the hexadecimal number *$10* is the decimal number *#10*).
In this example, the string *DW_AT_language* is the ***attribute***
***name***. The ***attribute*** ***name*** is actually a constant
defined in the *DWARF* standard (in this specific case, this is
the hexadecimal constant *$13*), but `objdump` conveniently decodes the
***attribute*** ***name*** constants to human-readable values, in this
case - the *DW_AT_language* ***attribute***. This is the programming
language mode that the compiler operated in when compiling a source
code file and generating a debug information tree for a compilation unit.
The number that follows in the example - the number *1* - is the
***attribute*** value for the *DW_AT_language* ***attribute***.
Please, remember, that a *DWARF* ***attribute*** has a ***name***
and a ***form*** of ***encoding*** - `objdump` is being very
helpful to us when it generates decoded *DWARF* debug information
dumps, so it has omitted the ***attribute*** ***form*** of ***encoding***,
which, however, is present in the *DWARF* debug information in
the compiler-generated object file, and in this specific case,
this ***attribute*** ***form*** of ***encoding*** is the described in
the *DWARF* standard *constant* form of encoding. In this specific
case, the *consant* *1* is defined in the *DWARF* standard to mean,
that the programming language mode that the compiler operated in
when generating the *DWARF* debug information tree of the
compilation unit observed, is the *C* programming language.
I.e., the compiler compiled *C* code.

I have reformatted the debug information tree for the sample
program from above, so that it is more clear how the generated debug information
corresponds to the source code:


```
| <0><b>: Abbrev Number: 1 (DW_TAG_compile_unit)
|    <c>   DW_AT_producer    : (indirect string, offset: 0x0): GNU C 4.9.3 20141119 (release) [ARM/embedded-4_9-branch revision 218278] -mcpu=cortex-m3 -mthumb -g -O0	
|    <10>   DW_AT_language    : 1	(ANSI C)
|    <11>   DW_AT_name        : (indirect string, offset: 0x7b): test.c	
|    <15>   DW_AT_comp_dir    : (indirect string, offset: 0x68): X:\troll\cxx-tests	
|    <19>   DW_AT_low_pc      : 0x0	
|    <1d>   DW_AT_high_pc     : 0x4c	
|    <21>   DW_AT_stmt_list   : 0x0	
+------> <1><25>: Abbrev Number: 2 (DW_TAG_subprogram)
|       |   <26>   DW_AT_name        : fib	
|       |   <2a>   DW_AT_decl_file   : 1	
|       |   <2b>   DW_AT_decl_line   : 4	
|       |   <2c>   DW_AT_prototyped  : 1	
|       |   <2c>   DW_AT_type        : <0x4b>	
|       |   <30>   DW_AT_low_pc      : 0x0	
|       |   <34>   DW_AT_high_pc     : 0x34	
|       |   <38>   DW_AT_frame_base  : 1 byte block: 9c 	(DW_OP_call_frame_cfa)
|       |   <3a>   DW_AT_GNU_all_tail_call_sites: 1	
|       |   <3a>   DW_AT_sibling     : <0x4b>	
|       +------> <2><3e>: Abbrev Number: 3 (DW_TAG_formal_parameter)
|                   <3f>   DW_AT_name        : n	
|                   <41>   DW_AT_decl_file   : 1	
|                   <42>   DW_AT_decl_line   : 4	
|                   <43>   DW_AT_type        : <0x4b>	
|                   <47>   DW_AT_location    : 2 byte block: 91 6c 	(DW_OP_fbreg: -20)
+------> <1><4b>: Abbrev Number: 4 (DW_TAG_base_type)
|           <4c>   DW_AT_byte_size   : 4	
|           <4d>   DW_AT_encoding    : 5	(signed)
|           <4e>   DW_AT_name        : int	
+------> <1><52>: Abbrev Number: 5 (DW_TAG_subprogram)
|           <53>   DW_AT_external    : 1	
|           <53>   DW_AT_name        : (indirect string, offset: 0x82): main	
|           <57>   DW_AT_decl_file   : 1	
|           <58>   DW_AT_decl_line   : 11	
|           <59>   DW_AT_prototyped  : 1	
|           <59>   DW_AT_type        : <0x4b>	
|           <5d>   DW_AT_low_pc      : 0x34	
|           <61>   DW_AT_high_pc     : 0x18	
|           <65>   DW_AT_frame_base  : 1 byte block: 9c 	(DW_OP_call_frame_cfa)
|           <67>   DW_AT_GNU_all_tail_call_sites: 1	
+------> <1><67>: Abbrev Number: 6 (DW_TAG_variable)
|           <68>   DW_AT_name        : x	
|           <6a>   DW_AT_decl_file   : 1	
|           <6b>   DW_AT_decl_line   : 2	
|           <6c>   DW_AT_type        : <0x76>	
|           <70>   DW_AT_external    : 1	
|           <70>   DW_AT_location    : 5 byte block: 3 0 0 0 0 	(DW_OP_addr: 0)
+------> <1><76>: Abbrev Number: 7 (DW_TAG_volatile_type)
|           <77>   DW_AT_type        : <0x4b>	
+------> <1><7b>: Abbrev Number: 6 (DW_TAG_variable)
	    <7c>   DW_AT_name        : y	
	    <7e>   DW_AT_decl_file   : 1	
	    <7f>   DW_AT_decl_line   : 2	
	    <80>   DW_AT_type        : <0x76>	
	    <84>   DW_AT_external    : 1	
	    <84>   DW_AT_location    : 5 byte block: 3 0 0 0 0 	(DW_OP_addr: 0)
```

Note that the sample program was compiled to an object file, and
not to an executable file. That was done in order to prevent
the linkage editor from running and linking in some necessary
runtime code for the target, which would make the generated debug information
larger. Compiling to an object file creates only debug
information about the source code file being compiled, which is
more convenient when first getting acquainted with *DWARF*.
Also, as an object file contains unrelocated addresses,
addresses of different entities in the debug information may coincide.
This is normal, these addresses will get relocated when finally
linking different object files to an executable file,
and will then have distinct values.

From looking at the debug information, we can conclude that the
debug information tree is of a compilation unit that has been
created from the source code file *test.c*
(DW_AT_name : (indirect string, offset: 0x7b): test.c).
The compilation unit was produced by the *gcc* compiler
(DW_AT_producer : (indirect string, offset: 0x0): GNU C 4.9.3 20141119 (release) [ARM/embedded-4_9-branch revision 218278] -mcpu=cortex-m3 -mthumb -g -O0).
The range of memory that this compilation unit occupies
in the target is from address *0* to address *0x4c*
(DW_AT_low_pc : 0x0, DW_AT_high_pc : 0x4c).
The compilation unit contains:
- a subprogram (at *DIE* offset *$25*) named **fib**,
declared in file number *1*, on source code line number *4*,
the range of machine-code instructions that the compiler
has generated for this subprogram spans from address *0*
to address *$34*. The return data type of this subprogram is
described, by the *DIE* at offset *$4b* in the *.debug_info* section
(DW_AT_type : <0x4b>). This subprogram has one child in the *DWARF*
debug information tree, at offset *$3e*, and this child is a formal parameter with 
the name **n**, which is stored in target memory at offset
*-20* from the target-specific *frame base* register.
(DW_AT_location : 2 byte block: 91 6c (DW_OP_fbreg: -20)).
The data type of this formal parameter is described
by the *DIE* at offset *$4b*
- a *base type* at offset *$4b*, which in the source code has the
name *int* (DW_AT_name : int), and is encoded in the target
as a 4-byte signed integer (DW_AT_byte_size : 4, DW_AT_encoding : 5 (signed)).
We already saw above that this *DIE* is referred from the
subprogram **fib** and its formal parameter **n**, so it turns out
that the return type of subprogram **fib**, as well as the
type of its formal parameter **n**, is actually the *C* language
type *int*						  

